import { sqliteTable, text, integer, real, primaryKey } from 'drizzle-orm/sqlite-core'
import { relations } from "drizzle-orm";

// Sessions represent a single interview-prep run for a specific role / company.
export const sessions = sqliteTable("sessions", {
  id: text("id").primaryKey(), // UUID
  createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
  jobTitle: text("job_title").notNull(),
  company: text("company").notNull(),
  jd: text("jd").notNull(), // full job description
});

// Questions asked within a session, generated by the Interview Question Agent.
export const questions = sqliteTable("questions", {
  id: text("id").primaryKey(),
  sessionId: text("session_id")
    .notNull()
    .references(() => sessions.id),
  createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
  questionText: text("question_text").notNull(),
  // JSON stringified scorecard object (competencies, signals, failure_modes)
  scorecard: text("scorecard", { mode: "json" }).$type<{
    competencies: string[];
    signals: string[];
    failure_modes: string[];
  } | null>(),
});

// Answers are tied to both the session and specific question.
export const answers = sqliteTable("answers", {
  id: text("id").primaryKey(),
  sessionId: text("session_id")
    .notNull()
    .references(() => sessions.id),
  questionId: text("question_id")
    .notNull()
    .references(() => questions.id),
  createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
  transcript: text("transcript"), // Whisper transcript
  audioUrl: text("audio_url"), // R2 object key
  rawJson: text("raw_json"), // raw Whisper / pipeline metadata
});

// Analysis rows represent agent evaluation of a specific answer.
export const analysis = sqliteTable("analysis", {
  id: text("id").primaryKey(),
  answerId: text("answer_id")
    .notNull()
    .references(() => answers.id),
  createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
  // JSON stringified evaluation payload from Interview Evaluation Agent
  analysisJson: text("analysis_json"),
});

// Optional audio metrics for tone & delivery.
export const audioMetrics = sqliteTable("audio_metrics", {
  id: text("id").primaryKey(),
  answerId: text("answer_id")
    .notNull()
    .references(() => answers.id)
    .unique(),
  createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
  speedWpm: real("speed_wpm"), // words per minute
  pitchVariance: real("pitch_variance"), // approximated 0–1
  volumeAvg: real("volume_avg"),
  fillerCount: integer("filler_count"),
  pausesRatio: real("pauses_ratio"), // 0–1 fraction of time in pause
});

// Relations

export const sessionsRelations = relations(sessions, ({ many }) => ({
  questions: many(questions),
  answers: many(answers),
}));

export const questionsRelations = relations(questions, ({ one, many }) => ({
  session: one(sessions, {
    fields: [questions.sessionId],
    references: [sessions.id],
  }),
  answers: many(answers),
}));

export const answersRelations = relations(answers, ({ one }) => ({
  session: one(sessions, {
    fields: [answers.sessionId],
    references: [sessions.id],
  }),
  question: one(questions, {
    fields: [answers.questionId],
    references: [questions.id],
  }),
  analysis: one(analysis, {
    fields: [answers.id],
    references: [analysis.answerId],
  }),
  audioMetrics: one(audioMetrics, {
    fields: [answers.id],
    references: [audioMetrics.answerId],
  }),
}));

export const analysisRelations = relations(analysis, ({ one }) => ({
  answer: one(answers, {
    fields: [analysis.answerId],
    references: [answers.id],
  }),
}));

export const audioMetricsRelations = relations(audioMetrics, ({ one }) => ({
  answer: one(answers, {
    fields: [audioMetrics.answerId],
    references: [answers.id],
  }),
}));


// --- Auth Tables ---
export const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
  email: text('email').notNull().unique(),
})

export const sessions = sqliteTable('sessions', {
  id: integer('id').primaryKey(),
  userId: integer('user_id').notNull().references(() => users.id),
  token: text('token').notNull().unique(),
})

// --- Health Monitoring Tables ---
export const healthChecks = sqliteTable('health_checks', {
  id: integer('id').primaryKey(),
  name: text('name').notNull().unique(), // e.g., 'D1_CONNECT', 'AI_PROVIDER_PING'
  status: text('status', { enum: ['PENDING', 'PASS', 'FAIL'] }).notNull().default('PENDING'),
  description: text('description'),
})

export const healthSessions = sqliteTable('health_sessions', {
  id: integer('id').primaryKey(),
  timestamp: integer('timestamp', { mode: 'timestamp_ms' }).notNull(),
  overallStatus: text('overall_status', { enum: ['PASS', 'FAIL'] }).notNull(),
})

export const healthLogs = sqliteTable('health_logs', {
  sessionId: integer('session_id').notNull().references(() => healthSessions.id),
  checkId: integer('check_id').notNull().references(() => healthChecks.id),
  status: text('status', { enum: ['PASS', 'FAIL'] }).notNull(),
  log: text('log'), // Raw error message
  aiExplanation: text('ai_explanation'), // AI-generated explanation
  aiResolution: text('ai_resolution'), // AI-generated fix
}, (table) => ({
  pk: primaryKey({ columns: [table.sessionId, table.checkId] }),
}))
